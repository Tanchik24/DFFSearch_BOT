{
  "getting_started": {
    "Installation": "<b>Начинаем с вами обучение с самого начала:</b> \"getting_started\", <b>параграф:</b> \"Installation\"\n\n<b>Установка</b>\nDFF можно легко установить на вашу систему с помощью менеджера пакетов pip:\n\n<code>pip install dff</code>\nЭтот фреймворк совместим с Python версии 3.8 и новее.\n\nВышеуказанная команда установит минимальные зависимости для начала работы с DFF. Процесс установки позволяет пользователю выбрать из различных пакетов в зависимости от их зависимостей:\n\n<code>pip install dff[json]</code>  # зависимости для использования JSON\n<code>pip install dff[pickle]</code> # зависимости для использования Pickle\n<code>pip install dff[redis]</code>  # зависимости для использования Redis\n<code>pip install dff[mongodb]</code>  # зависимости для использования MongoDB\n<code>pip install dff[mysql]</code>  # зависимости для использования MySQL\n<code>pip install dff[postgresql]</code>  # зависимости для использования PostgreSQL\n<code>pip install dff[sqlite]</code>  # зависимости для использования SQLite\n<code>pip install dff[ydb]</code>  # зависимости для использования Yandex Database\n<code>pip install dff[telegram]</code>  # зависимости для использования Telegram\n<code>pip install dff[benchmark]</code>  # зависимости для бенчмаркинга\n\nКроме того, вы также имеете возможность скачать исходный код напрямую из репозитория GitHub, используя команды:\n\n<code>git clone https://github.com/deeppavlov/dialog_flow_framework.git</code>\n<code>cd dialog_flow_framework</code>\nНаходясь в директории, вы можете выполнить команду <code>make venv</code>, чтобы установить все необходимые требования для библиотеки. Если вам нужно обновить требования, используйте команду <code>make clean</code> для удаления venv.\n",
    "Key concepts": "<b>Основные концепции</b>\nDFF — это мощный инструмент для создания сервисов для ведения диалога. Он позволяет разработчикам легко писать и управлять системами диалогов, определяя специальный диалоговый граф, который описывает поведение сервиса. DFF предлагает специализированный язык (DSL) для быстрого написания диалоговых графов, что упрощает для разработчиков создание чат-ботов для широкого спектра приложений, таких как социальные сети, колл-центры, веб-сайты, личные ассистенты и т.д.\n\nУ DFF есть несколько важных концепций:\n\n<b>Скрипт:</b> Прежде всего, для создания диалогового агента необходимо создать диалоговый Скрипт. Диалоговый скрипт — это словарь, где ключи соответствуют различным потокам. Скрипт может содержать несколько скриптов, которые также являются потоками, что необходимо для разделения диалога на суб-диалоги и их отдельной обработки.\n\n<b>Поток:</b> Как упоминалось выше, диалог делится на потоки. Каждый поток представляет суб-диалог, соответствующий обсуждению конкретной темы. Каждый поток также является словарем, где ключи — это узлы.\n\n<b>Узел:</b> Узел — это наименьшая единица потока диалога, и он содержит ответ бота на ввод пользователя, а также условие, которое определяет переход к другому узлу, будь то в текущем потоке или в другом.\n\n<b>Ключевые слова:</b> DFF использует несколько специальных ключевых слов. Эти ключевые слова являются ключами в словарях внутри скрипта. Самые важные для использования фреймворка — это ключевые слова RESPONSE и TRANSITIONS. Первое соответствует ответу, который бот отправит пользователю из текущего узла. Второе соответствует условиям перехода из текущего узла в другие узлы.\n"
  },
  "Basic Concepts": {
    "Introduction": "<b>Фреймворк Dialog Flow (DFF)</b> — это современный инструмент для проектирования сервисов для ведения диалога.\n\nDFF вводит специализированный предметно-ориентированный язык (DSL), основанный на стандартных функциях и структурах данных Python, что делает его очень доступным для разработчиков любого уровня квалификации для проектирования скрипта взаимодействия пользователя с ботом. Скрипт представляет собой диалоговый граф, где каждый узел равен определенному состоянию диалога, т.е. конкретному ходу разговора. Граф включает большую часть логики разговора и охватывает один или несколько пользовательских сценариев, все в одном словаре Python.\n\nВ этом учебном пособии мы описываем основы API DFF и проведем вас через процесс создания и поддержки сервиса для ведения диалога с помощью DFF.\n",
    "Creating Conversational Services with DFF: Defining Dialogue Goals and User Scenarios": "<b>Установка</b>\nЧтобы начать работу с DFF, вам необходимо установить его основные зависимости, что можно сделать с помощью следующей команды:\n\n<b>pip3 install dff</b>\n<b>Определение целей диалога и пользовательских сценариев</b>\nДля создания сервиса ведения диалога с использованием фреймворка Dialog Flow Framework (DFF) начните с определения общей цели диалога и разбивки диалога на меньшие сценарии на основе намерений или действий пользователя, которые вы хотите охватить. Предметно-ориентированный язык DFF упрощает разделение сценария диалога на потоки, т.е. именованные группы узлов, объединенные определенной целью.\n\nНапример, если одним из вариантов диалога, который мы предлагаем пользователю, является игра, бот может иметь поток «игра», который содержит состояния диалога, связанные с этой темой, в то время как другие потоки охватывают другие темы, например, поток «время» может включать вопросы и ответы, связанные со временем, «погода» — с погодой и т.д.\n",
    "Creating Dialogue Flows for User Scenarios": "<b>Создание потоков диалогов для пользовательских сценариев</b>\nПосле установки DFF вы можете определить потоки диалогов, ориентированные на различные пользовательские сценарии, и объединить их в глобальный объект сценария. Поток состоит из одного или нескольких узлов, представляющих ходы разговора.\n\n<b>Примечание:</b>\nДругими словами, объект сценария имеет 3 уровня вложенности: сценарий - поток - узел.\n\nДопустим, единственным пользовательским сценарием сервиса является игра в пинг-понг чат-бота с пользователем. Практическая реализация этого заключается в том, что бот должен отвечать «понг» на сообщения, которые говорят «пинг», и обрабатывать любые другие сообщения как исключения. Псевдокод для указанного потока будет следующим:\n\nЕсли пользователь пишет \"Привет!\":\n    Ответить \"Привет! Давай играть в пинг-понг!\"\n\n    Если пользователь затем пишет \"Пинг\" или \"пинг\":\n        Ответить \"Понг!\"\n        Повторить это поведение\n\nЕсли пользователь пишет что-то другое:\n    Ответить \"Это против правил\"\n    Вернуться к ответу \"Привет! Давай играть в пинг-понг!\" если пользователь что-то пишет\nЭто оставляет нас с одним диалоговым потоком в диалоговом графе, который мы изложили ниже, с аннотациями для каждой части графа, доступными под фрагментом кода.\n\nПример потока и сценария:\n```python\nfrom dff.pipeline import Pipeline\nfrom dff.script import TRANSITIONS, RESPONSE, Message\nimport dff.script.conditions as cnd\n\nping_pong_script = {\n    \"greeting_flow\": {\n        \"start_node\": {\n            RESPONSE: Message(),  # ответ начального узла пропускается\n            TRANSITIONS: {\n                (\"greeting_flow\", \"greeting_node\"):\n                    cnd.exact_match(Message(\"/start\")),\n            },\n        },\n        \"greeting_node\": {\n            RESPONSE: Message(\"Привет!\"),\n            TRANSITIONS: {\n                (\"ping_pong_flow\", \"game_start_node\"):\n                    cnd.exact_match(Message(\"Привет!\"))\n            }\n        },\n        \"fallback_node\": {\n            RESPONSE: fallback_response,\n            TRANSITIONS: {\n                (\"greeting_flow\", \"greeting_node\"): cnd.true(),\n            },\n        },\n    },\n    \"ping_pong_flow\": {\n        \"game_start_node\": {\n            RESPONSE: Message(\"Давай играть в пинг-понг!\"),\n            TRANSITIONS: {\n                (\"ping_pong_flow\", \"response_node\"):\n                    cnd.exact_match(Message(\"Пинг!\")),\n            },\n        },\n        \"response_node\": {\n            RESPONSE: Message(\"Понг!\"),\n            TRANSITIONS: {\n                (\"ping_pong_flow\", \"response_node\"):\n                    cnd.exact_match(Message(\"Пинг!\")),\n            },\n        },\n    },\n}\n\npipeline = Pipeline.from_script(\n    ping_pong_script,\n    start_label=(\"greeting_flow\", \"start_node\"),\n    fallback_label=(\"greeting_flow\", \"fallback_node\"),\n)\n\nif __name__ == \"__main__\":\n    pipeline.run()\n"
  },
  "Context guide": {
    "Introduction": "",
    "API": "api"
  }
}